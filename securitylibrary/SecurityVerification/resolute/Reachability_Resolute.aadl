package Reachability_Resolute
public
	annex resolute {**

-------------------
-- Connectivity
-------------------

-- Ensure that all features of all componetns are conencted
-- Result includes a log of all features and their connections
all_features_are_connected() <=
	** "All features of all components in the system are connected" **
	forall (comp : component) . 
		not((comp instanceof data) or (comp instanceof bus)) => conn_eq_feat(comp)

conn_eq_feat(comp : component) <=
	** "All features of " comp " are connected" **
	forall(feat : features(comp)). feat_is_connected(feat) 

feat_is_connected(feat : feature) <= 
	** "The feature: " feat " is connected" **
	connections(feat) <> {} and record_set(connections(feat),"The connections are ")
	
	        
component_is_sink(comp : component) <=
  ** comp " has no outgoing connections" **
	forall(feat : features(comp)). direction(feat) = "in" or outgoing_connections(feat) = {} 
	        
component_is_source(comp : component) <=
  ** comp " has no incoming connections" **
	forall(feat : features(comp)). direction(feat) = "out" or incoming_connections(feat) = {} 

-- TODO for access connections:
-- 1) get data component according to r/w.
-- 2) from data component get everyone reachable (who reads)

-------------------------------------
-- set of components reachable by port or data access connections
-------------------------------------
show_reachable_endpoints(comp: component)<=
** comp " reaches " ep **
let ep : {component} = reachable_endpoints(comp);
true--log_set(next,"reached set ",true)

	show_contained_threads(pr : component) <=
	** "Threads contained in given component (process) " pr "  are " thrds **
		let thrds: {component} = contained_threads(pr); true

-- return set of reachable components that sinks 
reachable_endpoints(c : component) : {component} =
	  let outconns: {connection} = outgoing_connections(c);
	  let dummy: bool = log_set(outconns,"conns "+name(c), true);
	  if  outconns = {}
	  then {c} 
 	  else  
  		{c2 for (conn : outconns) (c2 : reachable_endpoints(destination_component(conn)))}


-- all components that are reachable via port or data access connections from the given component
-- we consider direct and indirect reachability
-- the use of a set ensures that we do not recurse forever
reach(c : component) : {component} =
    recusive_reach({c})

-- support method to expand on a set of reachable components by the next directly rachable components
-- the use of a set ensures that we do not recurse forever
recusive_reach(curr: {component}) : {component} =
    let next : {component} = union(curr, next_reach(curr));
    let dummy : bool = log_set(next,"addnext set ",true);
    if next = curr then
        curr
    else
        recusive_reach(next)


-- next reachable components 
next_reach(curr : {component}) : {component} =
    {y for (x : curr) (y : reachable_components(x))} 


-- components reachable by connection (port, data access) from given component
reachable_components(comp : component) : {component} =
    {c for (conn : connections(comp))
        (c : reachable_components_via_connection(comp, conn))}

-- What components can 'comp' reach directly via 'conn'
--
-- This is complicated due to data access connections which seem to ignore
-- normal aadl directionality, and instead use an access rights property
reachable_components_via_connection(comp : component, conn : connection) : {component} =
  let comps : {component} =
  -- a direct port connection
  if is_port_connection(conn) then
    if source_component(conn) = comp then {destination_component(conn)} else {}
  -- a component reading from 'comp' as a data component via read access on 'conn'
  else if is_data_access_connection(conn) then
    if comp = source_component(conn) and has_read_access(destination(conn)) then
      {destination_component(conn)}
    else if comp = destination(conn) and has_read_access(source(conn)) then
      {source_component(conn)}
    else
      {}
  -- 'comp' writing to a data component via write access on 'conn'  
  else if destination(conn) instanceof data and has_write_access(source(conn)) then
    {destination_component(conn)}
  else if source(conn) instanceof data and has_write_access(destination(conn)) then
    {source_component(conn)}
  -- Other connections unsupported at this time
  else
    {};
    if log_set(comps,"reachme ",true) then comps else comps

	**};
end Reachability_Resolute;
