package Flight_Soundness_Soundness_Resolute
public
	annex resolute {**
only_gs_encrypt() <= 
  ** "Only the Ground Station can send commands that pass decrypt" **
  let algo1 : string =
    property(FlightMissing::decryptTask_uart5, SMACCM::Encryption_Algorthim);
  let algo2 : string =
    property(FlightMissing::decryptTask_uart1, SMACCM::Encryption_Algorthim);
  algo1 = algo2 and
  authenticated_encryption(algo1) and  
  private_key()

authenticated_encryption(e : string) <=
  ** "The encryption algorithm " e " is strong and authenticated. "
     "Messages cannot be forged or manipulated" **
  e = "AES-128-GCM" or e = "AES-128-CTR-HMAC-SHA1"

private_key() <=
  ** "The encryption key is private to the UAV and Ground Station" **
  key_randomly_generated() and
  gs_private_key() and
  transmit_private_key() and
  uav_private_key() and
  uav_private_key_unchanged()

key_randomly_generated() <=
  ** "The encryption key is randomly generated and cannot be guessed" **
  true

gs_private_key() <=
  ** "The Ground Station does not leak the encryption key" **
  true

transmit_private_key() <=
  ** "The encryption key is securely transmitted to the UAV and Ground Station" **
  true
 
uav_private_key() <=
  ** "The UAV does not leak the encryption key" ** 
  true
  
uav_private_key_unchanged() <=
  ** "The encryption key is unmodified while on the UAV" **
  true

MOTORS : {component} = instances(FlightMissing::Motor)
MAIN_LOOP : component = instance(FlightMissing::flight_gen_process)

motors_only_receive_decrypt() <=
	** "The UAV motors only execute commands that pass decrypt" **
	motors_only_receive_from_mainloop(MAIN_LOOP) and
	all_commands_to_mainloop_pass_decrypt_before_motors(MAIN_LOOP)
	
-- TODO: What should we say about non-data port connections?
motors_only_receive_from_mainloop(mainloop : component) <=
	** "The UAV motors only receive commands from " mainloop **
	forall (m : MOTORS).
	  forall (c : connections(m)).
	    (is_data_port_connection(c) or is_event_data_port_connection(c)) =>
	      comes_from_mainloop(c, mainloop)

comes_from_mainloop(c : connection, mainloop : component) <=
	** c " comes from " mainloop **
	 contained(source(c), mainloop)

all_commands_to_mainloop_pass_decrypt_before_motors(mainloop : component) <=
  ** "All commands to " mainloop " pass decrypt before reaching UAV motors" **
  all_inputs_decrypt_or_sensors(mainloop)

all_inputs_decrypt_or_sensors(mainloop : component) <=
    ** "All inputs to " mainloop " are sensor data or pass decrypt before reaching UAV motors" **
	forall (f : flatten_features(features(mainloop))).
	    is_incomming(f, mainloop) =>
	      is_sensor_data(f) or feature_confined_to_decrypt(f, mainloop)

is_incomming(f : feature, x : component) : bool =
  exists (c : connections(f)). contained(destination(c), x)

is_sensor_data(f : feature) <=
  ** f " only receives sensor data" **
  has_type(f) and
  (type(f) = DATATYPES::Magnetometer_Data or
   type(f) = DATATYPES::Barometric_Data or
   type(f) = DATATYPES::Motion_Data or
   type(f) = DATATYPES::Motion_Data.Impl or
   type(f) = DATATYPES::Battery_Data or
   type(f) = DATATYPES::GPS_Data or
   type(f) = DATATYPES::Reset_Data )

feature_confined_to_decrypt(f : feature, mainloop : component) <=
  ** "Commands to " f " pass through decrypt before reaching the UAV motors" **
  forall (c : connections(f)).
    contained(destination(c), mainloop) =>
      component_confined_to_decrypt(destination_component(c), mainloop)
      
component_confined_to_decrypt(c : component, mainloop : component) <=
  ** "Commands to " c " pass through decrypt before reaching the UAV motors" **
  let reach : {component} = predecrypt_reach(c, mainloop);
    component_confined_to_decrypt_by_set(c, reach)

predecrypt_reach(c : component, mainloop : component) : {component} =
  recursive_predecrypt_reach({c})
  
recursive_predecrypt_reach(curr : {component}) : {component} =
  let next : {component} = union(curr, next_predecrypt_reach(curr));
  if next = curr then
    curr
  else
    recursive_predecrypt_reach(next)
   
next_predecrypt_reach(curr : {component}) : {component} =
  {y for (x : curr) (y : reachable_components(x)) | not is_decrypt(x)}

is_decrypt(comp : component) : bool =
  type(comp) = FlightMissing::decryptTask_uart1 or
  type(comp) = FlightMissing::decryptTask_uart5

component_confined_to_decrypt_by_set(x : component, reach : {component}) <=
  ** "Commands to " x " not passing through decrypt are confined and "
     "cannot reach UAV motors. Confinement set: " reach **
  forall (y : reach). cannot_reach_UAV_motors(y)

cannot_reach_UAV_motors(x : component) <=
  ** x " cannot communicate directly to UAV motors" **
  not member(x, MOTORS) and
  forall (conn : connections(x)).
    source_component(conn) = x => not member(destination_component(conn), MOTORS)
		
	**};
end Flight_Soundness_Soundness_Resolute;
