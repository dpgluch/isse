package Security_Levels_Resolute
public
	annex Resolute {**
			
	check_mils_policy (self:component) <=
	** "Check security constraints" **
	check_mils_application_security_rules(self) and check_implementation_security_exposure(self)

	-------------------------------------------------------------
	--  Security level/domain rules
	-------------------------------------------------------------
	check_mils_application_security_rules (self:component) <=
	** "All security level/domain rules hold" ** 
	forall_buses_hardware_connected_by_bus_same_security_level (self) and -- R0
	forall_port_connections_same_security_level(self) and -- R1
	forall_memory_bound_components_same_security_level (self) and           -- R2
	forall_processor_bound_components_same_security_level (self) and -- R3
	forall_virtual_processor_bound_components_same_security_level (self) and -- R3
	forall_process_threads_in_process_same_security_level (self) and  -- R4
	forall_components_feature_security_levels_supported_by_component (self) and  -- R5
	forall_hardware_relay_channel_between_buses (self)    -- R6, cwe 514

----------------------------------
-- Security levels/domains associated with (hardware) components connected to buses must be the same or trusted
--
-- Note: buses may be actual buses or systems/abstract components with bus access connections
-- The rules assume Security_Level or Information_Security_Level_US and optionally Security_Domain properties
-- are assigned to components connected to buses.  
-- The 
----------------------------------
	
	forall_buses_hardware_connected_by_bus_same_security_level (self:component) <=
	** "For all buses in specified component: Components connected to bus have the same security level/domain at least one is trusted" ** 
	forall (b : bus ) . hardware_connected_by_bus_same_security_level (b) 
	
	
	hardware_connected_by_bus_same_security_level (thebus : component) <=
	** "Components connected to given bus " thebus" have the same security level/domain at least one is trusted" ** 
		let busconnections: {connection} = connections (thebus);
		forall (conn1 : busconnections) (conn2 : busconnections). 
			conn1 <> conn2 => 
			(   let target1: component = other_connection_end(conn1, thebus);
			    let target2: component = other_connection_end(conn2, thebus);
			    target1 <> target2 => 
			    	same_security_level_or_trusted(target1, target2)
			)

	-- all connected hardware security level/domains are supported by bus (or system/abstract) 
	forall_hardware_connected_to_bus_supported_security_level (thebus : bus) <=
	** "bus " thebus" supports same security level/domain as connected components" ** 
			forall (conn : connections (thebus)). 
			(   let target: component = other_connection_end(conn, thebus);
			    is_security_level_subset_or_superset_is_trusted(target, thebus)
			)

	forall_hardware_relay_channel_between_buses (self:component) <=
	** "For all components: component is relay channel between buses by relaying messages to components with different security levels/domains" ** 
	forall (hw : hardware) . relay_channel_between_buses (hw)
	
	
	
	relay_channel_between_buses (middle : component) <=
	**  middle " is relay channel between buses by relaying  messages to components with different security levels/domains" ** 
	forall (thebus1: bus) (thebus2: bus). 
	(thebus1 <> thebus2) => are_connected (middle,thebus1) 
	and are_connected (middle,thebus2) and hardware_connected_by_bus_same_security_level(thebus1)
	and hardware_connected_by_bus_same_security_level(thebus2)
		
----------------------------------
-- Security levels/domains associated with components bound to memory, processor, virtual processor must be the same or trusted
--
-- The rules assume Security_Level or Information_Security_Level_US and optionally Security_Domain properties
-- are assigned to the bound components.  
-- At this time any hardware component security properties are ignored.
----------------------------------
	forall_memory_bound_components_same_security_level (self:component) <=
	** "For all memories: all bound components have same security level/domain or are trusted" **
	forall (mem : memory) .
		memory_bound_components_same_security_level(mem)
 
 	memory_bound_components_same_security_level (mem: memory) <=
	** "All bound components have same security level/domain or are trusted" **
	forall (pr1 : component) (pr2 : component)  . pr1 <> pr2 and
		is_bound_to (pr1, mem) and is_bound_to (pr2, mem) =>
		same_security_level_or_trusted (pr1,pr2)
 
	forall_processor_bound_components_same_security_level (self:component) <=
	** "For all processors: bound components have same security level/domain or are trusted" **
	forall (cpu : processor) .
		processor_bound_components_same_security_level(cpu)

	processor_bound_components_same_security_level (cpu: processor) <=
	** "Processor " cpu ": bound components have same security level/domain or are trusted" **
	forall (pr1 : component) (pr2 : component) . pr1 <> pr2 and
		member(cpu,bound_processors(pr1)) and
		member(cpu,bound_processors(pr2)) => 
		same_security_level_or_trusted (pr1,pr2)

	forall_virtual_processor_bound_components_same_security_level (self:component) <=
	** "For all virtual processors: bound components have same security level/domain or are trusted" **
	forall (vcpu : virtual_processor) .
		virtual_processor_bound_components_same_security_level(vcpu)

	virtual_processor_bound_components_same_security_level (vcpu: virtual_processor) <=
	** "Virtual processor " vcpu ": bound components have same security level/domain or are trusted" **
	forall (pr1 : component) (pr2 : component) . pr1 <> pr2 and
		member(vcpu,bound_processors(pr1)) and
		member(vcpu,bound_processors(pr2)) => 
		same_security_level_or_trusted (pr1,pr2)

	-- for all components bound to memory security level/domains are supported 
	forall_components_bound_to_memory_supported_security_level (thememory : memory) <=
	** "Memory " thememory" supports same security level/domain of all bound components" ** 
			forall (comp : component). is_bound_to(comp,thememory) =>
			    is_security_level_subset_or_superset_is_trusted(comp, thememory)

	-- for all components directly bound to processor (or system/abstract) security level/domains are supported 
	forall_components_bound_to_processor_supported_security_level (theprocessor : component) <=
	** "Processor " theprocessor" supports same security level/domain of all bound components" ** 
			forall (comp : component). is_bound_to(comp,theprocessor) =>
			    is_security_level_subset_or_superset_is_trusted(comp, theprocessor)

	-- for all components directly bound to virtual processor security level/domains are supported 
	forall_components_bound_to_virtual_processor_supported_security_level (theVP : component) <=
	** "memory " theVP" supports same security level/domain of all bound components" ** 
			forall (comp : component). is_bound_to(comp,theVP) =>
			    is_security_level_subset_or_superset_is_trusted(comp, theVP)


	
----------------------------------
-- Security levels/domains associated with application must be the same or trusted.
-- We deal with port conenction ends, threads in processes, and features (information) supported by threads (agents)
--
-- The rules assume Security_Level or Information_Security_Level_US and optionally Security_Domain properties
-- are assigned to the bound components.  
-- At this time any hardware component security properties are ignored.
----------------------------------
	forall_port_connections_same_security_level (self:component) <=
	** "For all port connections: connected components have the same security level/domain at least one is trusted" **
		forall  (pc : {conn for (conn:connection)| is_port_connection(conn)}).
		port_connection_same_security_level(pc)

	port_connection_same_security_level (conn : connection) <=
	** "connected components have the same security level/domain at least one is trusted" **
		let src : component = source_component (conn);
		let dst : component = destination_component (conn);
		same_security_level_or_trusted (src,dst)
		

	forall_process_threads_in_process_same_security_level (self:component) <=
	** "For all processes: Threads contained in given processes have same security level/domain or are trusted" **
	forall (pr : process)  .
		is_trusted(pr) or threads_in_component_same_security_level(pr)

	threads_in_component_same_security_level (pr : component) <=
	** "Threads contained in given component (process) " pr " have same security level/domain or are trusted" **
		let thrds: {component} = contained_threads(pr);
		forall (thr1 : thrds) (thr2 : thrds) .
				same_security_level_or_trusted (thr1,thr2)



	forall_components_feature_security_levels_supported_by_component (self:component) <=
	** "For all components: component supports security levels/domain of ports or is trusted" **
	forall (comp : component) . feature_security_levels_supported_by_component (comp)

	feature_security_levels_supported_by_component (comp : component) <=
	** comp " supports security levels/domain of ports or is trusted" **
	  not(is_trusted (comp)) =>
	  forall (prt : {f for (f:features (comp)) | is_port (f)})
		. is_security_level_subset_or_superset_is_trusted (comp,prt)
	
--------------------------------------------------------------------------------------------
-- Security Level/Domain Utility Claim Functions that deal with all three security level/soamin properties
-- or wrap a suecirity utility compute function to cause recording in the result structure
--------------------------------------------------------------------------------------------

	-- handles both forms of security level as well as security domain
	-- SecurityDomains: neither or both model elements must have it and the values must be the same
	-- SecurityLevels, Information_Security_Level_US:  neither model element must have either proeprty or both elements must have the same property and the values must be the same
	-- returns false if either has no security level or domain properties or no Trusted proeprty
  	same_security_level_or_trusted(target1 : aadl, target2 : aadl) <= 
	** target1 " and " target2 " have same security level/domain or at least one is trusted"  **
		(is_trusted(target1) or is_trusted(target2) or
			(is_same_security_domain(target2,target1) or neither_has_security_domains(target2,target1) and 
				(is_subset_security_level(target2, target1) or is_subset_info_security_level(target2,target1)
					or neither_has_security_levels(target1,target2)	
				)
			) 
		)
		orelse 
		fail ** target1 " and "target2 " are not trusted and have different security levels or domains" **

	-- handles both forms of security level as well as security domain
	-- SecurityDomains: neither or both model elements must have it and one must be a subset of the other
	-- SecurityLevels, Information_Security_Level_US:  both elements must have the same property and one must be a subset of the other
	-- returns false if either has no security level or domain properties or no Trusted proeprty
	is_security_level_subset_or_superset_is_trusted (subset : aadl, superset : aadl) <= 
	** subset " has security level/domain subset of " superset " or " superset " is trusted"**
		(is_trusted(superset) or 
			(is_subset_security_domain(subset,superset) or neither_has_security_domains(subset,superset) and 
			   (is_subset_security_level(subset, superset) or is_subset_info_security_level(subset,superset)
			   ) 
			)
		)
		orelse
		fail ** superset " cannot handle "subset " security levels or domains" **
 	
	-- connection binding targets (virtual bus or hardwaare) are encrypted.
	-- for a virtual bus target if it is not encrypted we examine its conneciton binding targets.
	-- Both virtual buses and hardware can be marked as encrypted 
	uses_virtual_buses_with_encryption (conn: connection) <=
	** "connection is bound to at least one layer of encrypted virtual bus(es)" **
	connection_binding_targets_encrypted(conn) 
  
	**};
end Security_Levels_Resolute;
