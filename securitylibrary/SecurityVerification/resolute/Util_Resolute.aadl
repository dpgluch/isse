package Util_Resolute
public
	annex Resolute {**

--------------------------
-- Component type related methods
--------------------------
   
	-- is abstract component
   is_abstract (c : component) : bool =
      c instanceof abstract
   
   -- a hardware component, i.e., device, memory, bus, processor, system
   is_hardware (comp : component) : bool =
      (is_processor(comp) or is_device(comp) or is_memory(comp) or
       is_system(comp)  or is_bus (comp) or is_abstract(comp)) 

--------------------------
-- Component instance related methods
--------------------------
  -- return set of hardware components in instance model
  hardware: {component} =
	{c for  (c:component)| is_hardware(c)}      

	-- return set of threads directly or indirectly contained in the component
	contained_threads(c : component) : {thread} =
	  if is_thread(c)
	  then {c} 
 	  else  
  		{c2 for (c1 : subcomponents(c)) (c2 : contained_threads(c1))}
	
--------------------------
-- Connection related methods
--------------------------

	-- A connection exists between the components or their features
	are_connected (comp1 : component, comp2 : component) : bool =
		exists (conn : connections (comp1)) . destination_component(conn) = comp2 or source_component(conn) = comp2

   -- For a given connection and a given component return the component on the other end of the connection
   other_connection_end(conn: connection,comp: component): component =
   		if (destination_component(conn) = comp) 
		then
			source_component(conn)
   		else
   			destination_component(conn)
 
	-- connection is bus access connection
	is_bus_access_connection(c : connection) : bool =
  		(source_component(c) instanceof bus) or (destination_component(c) instanceof bus)

	-- connection is data access connection
	is_a_data_access_connection(c : connection) : bool =
  		(source_component(c) instanceof data) or (destination_component(c) instanceof data)

	-- return incoming connections for a given component or feature
	incoming_connections(t : aadl) : {connection} =
	  { c for (c : connections(t)) | destination_component(c) = t }

	-- return outgoing connections for a given component or feature
	outgoing_connections(t : aadl) : {connection} =
	  { c for (c : connections(t)) | source_component(c) = t }

--------------------------
-- Binding related methods
--------------------------

	-- return the set of hardware components the given component or connection is directly or indirectly bound to
	connection_bound_hardware(c : aadl) : {component} =
	  if is_virtual_bus(c) 
	  then 
  		{cc2 for (cc1 : connection_binding(c)) (cc2 : connection_bound_hardware(cc1))}
 	  else
	    {c} 

	-- return the set of processors the given component is directly or indirectly bound to
	bound_processors(c : aadl) : {component} =
	  if is_virtual_processor(c)
 	  then
  		{cp2 for (cp1 : processor_binding(c)) (cp2 : bound_processors(cp1))}
 	  else
	    {c} 
  
  -- return list of components the connection or virtual bus is bound to via connection binding
  -- we return a list because some elements may be listed multiple times in a sequence in a conenction binding
  connection_binding(logical : aadl) : [component] =
  	  property(logical, Deployment_Properties::Actual_Connection_Binding,[]) 

   -- return list of processors the component is bound to via processor binding
  processor_binding(logical : aadl) : [component] =
   	  property(logical, Deployment_Properties::Actual_Processor_Binding,[])
 
   -- return list of memory components the component is bound to via memory binding
  memory_binding(logical : aadl) : [component] =
  	  property(logical, Deployment_Properties::Actual_Memory_Binding,[])

   -- return list of components the logical component is bound to via function binding
  function_binding(logical : aadl) : [component] =
   	  property(logical, Deployment_Properties::Actual_Function_Binding,[])
 
 
 	
	-- connection between components on two different processors
   is_distributed(conn : connection) : bool =
   	let srcHW : [component] = processor_binding(source_component (conn));
   	let dstHW : [component] = processor_binding(destination_component (conn));
      srcHW <> dstHW
 
 ----------------------------
 -- functions to return  property values
 -----------------------------    
 
  -- return queue size with default value of 1 if not set 
  queue_size(element: aadl) : int =
  	property (element, Communication_Properties::Queue_Size,1)
    
  -- true if has write only or read/write access. If not set, default is read/write.  
  has_write_access(a : aadl) : bool =
	  let right : string = property(a, Memory_Properties::Access_Right, "read_write");
  		(right = "write_only" or right = "read_write")

  -- true if has read only or read/write access. If not set, default is read/write.  
  has_read_access(a : aadl) : bool =
	  let right : string = property(a, Memory_Properties::Access_Right);
 		(right = "read_only" or right = "read_write")
  
  -- true if control control protocol property is set.  
  has_concurrency_control (d : aadl) : bool = 
	has_property (d , Thread_Properties::Concurrency_Control_Protocol)

 
 ----------------------------
 -- functions for ordered lists
 -----------------------------    

	-- support method to determine ordering
	is_before(seclevels: [string], first:string, second: string): bool =
	let match : string = head(seclevels);
	if (match = first) then
		true
	else if (match = second) then
		false
	else 
		is_before(tail(seclevels),first,second)
 
 ----------------------------
 -- functions for result logging and debugging
 -----------------------------    

  	-- record a set of model elements in the result structure
  	record_set(s : {aadl}, msg : string) <=
   		 ** msg ": " s **
   		 true

  	-- record a set of model elements in the result structure
  	record_list(s : [aadl], msg: string) <=
   		 ** msg ": "s **
   		 true

  	-- record a model element in the result structure
  	record_element(s : aadl, msg: string) <=
   		 ** msg ": " s **
   		 true

  	-- log a set of model elements to the console
  	log_set(s : {aadl}, msg : string, log_to_console: bool) : bool = 
   		 log_to_console => debug(msg+ ": ",s)

  	-- log a set of model elements to the console
  	log_list(s : [aadl], msg: string, log_to_console: bool) : bool =
    	log_to_console => debug( msg+": ",s)

  	-- log a model elements to the console
  	log_element(s : aadl, msg: string, log_to_console: bool) : bool =
    	log_to_console => debug( msg+": ",s)
  
	**};
end Util_Resolute;
