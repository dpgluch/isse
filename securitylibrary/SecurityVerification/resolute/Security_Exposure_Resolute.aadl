package Security_Exposure_Resolute
public
	annex Resolute {**
	-------------------------------------------------------------
	--  Security exposure - both physical and design flaw exposure
	-------------------------------------------------------------
	check_implementation_security_exposure (self:component) <=
	** "Check the architecture for security risk exposure and common weaknesses" **
		forall_connections_encrypted_over_exposed_hardware (self) and  --R7
		forall_connections_across_processors_connection_is_encrypted(self) and  -- R8
		forall_connections_no_buffer_overflow(self) and -- cwe131
		forall_data_shared_components_uses_concurrency_control_protocol(self) and -- cwe362
		sufficient_encryption_strength(self) and
		forall_connections_consistent_use_of_unclassified_data_and_encrypted_classfied_data_on_port_connections(self) and
		forall_connections_same_data_type_or_size_and_consistent_data_model_spec(self) --cwe805

----------------------------------
-- Encryption when hardware used by connections is physically exposed.
----------------------------------

--- NOTE: we should also deal with physical exposure of memory (disks) and their encryption)
--- NOTE: physical exposure of processors: how are htey protected?
	
	--  check encryption of connections over exposed hardware.  
	--  Encryption is represented by a virtual bus with a property indicating that it uses encryption.
	forall_connections_encrypted_over_exposed_hardware(self:component) <=
	** "For all connections: use encryption if connection is bound to exposed hardware" **
	forall(conn:connection).
	encrypted_over_exposed_hardware (conn)  
	
	encrypted_over_exposed_hardware(conn: connection) <=
	** "Use encryption for exposed hardware on connection " conn **
	connection_binding_targets_encrypted_or_not_exposed(conn)

	--
	--  All connections across different processors must be encrypted
	--
	-- Note: this is not related to physical exposure
	
	forall_connections_across_processors_connection_is_encrypted (self:component) <=
	** "For all connections: encrypted when across different processors" ** 
	forall (logicalconn : {conn for (conn : connection)| not is_bus_access_connection(conn)}) . 
	connection_across_processors_is_encrypted(logicalconn)

	connection_across_processors_is_encrypted (conn :connection) <=
	** "Connection across different processors must be encrypted" ** 
	is_distributed(conn) => uses_virtual_buses_with_encryption (conn)

-----------------------------------------------
-- Use of encryption for all but unclassified information
-----------------------------------------------	
	--
	-- CWE-311: Check that all but unclassified data are encrypted 
	--  We check that a bound virtual bus defines the security encryption.
	-- Also ensure that unclassified information connection have have unclassified or trusted participants
	forall_connections_consistent_use_of_unclassified_data_and_encrypted_classfied_data_on_port_connections (self:component) <=
	** "CWE311: Consistent use of unclassified connections and encrypted classified connections" ** 
			forall  (pc : {conn for (conn:connection)| is_port_connection(conn)}).
			consistent_unclassified_connection (pc) and encryption_of_classified_data_on_connection (pc) 

	forall_connections_encrypted_classified_connections (self:component) <=
	** "CWE311-B: Encrypted classified connections" ** 
			forall  (pc : {conn for (conn:connection)| is_port_connection(conn)}).
			encryption_of_classified_data_on_connection (pc) 

	forall_connections_consistent_unclassified_connections (self:component) <=
	** "CWE311-A: Consistent use of unclassified connections" ** 
			forall  (pc : {conn for (conn:connection)| is_port_connection(conn)}).
			  consistent_unclassified_connection (pc)
	
	--  we check that source is unclassified or source is trusted and destination is unclassified or destination is trusted
	--  
	consistent_unclassified_connection (conn : connection) <=
	** "Consistent communication of unclassified information on " conn ** 
		let src : component = source_component (conn);
		let dst : component = destination_component (conn);
		(is_unclassified (src) andthen is_unclassified (dst) or is_trusted (dst))
		and (is_unclassified (dst) andthen 
			is_unclassified (src) or is_trusted (src))

	--  for classified data connection must be encrypted 
	-- for unclassified on both ends return true as we do this for all connections
	encryption_of_classified_data_on_connection (conn : connection) <=
	** "Encryption of classified information on " conn ** 
	not(is_unclassified (source_component (conn))) or not(is_unclassified (destination_component (conn))) 
	=>
	 	connection_binding_targets_encrypted(conn)


	--
	-- CWE-327 - use of risky or weak security protocol
	--  The list of potential good/weak encryption mechanisms
	--  are listed here: https://www.owasp.org/index.php/Guide_to_Cryptography#Algorithm_Selection
	--	 
	sufficient_encryption_strength (self:component) <=
	** "CWE327: Use of risky or weak security protocol" ** 
	forall (c : component) . true =>
	true
	--  FIXME: we need to get access to a record in resolute to
	--  do that. It means, access to the members of the
	--  encryption property.
	--  Pending bug #40 in smaccm
	--  https://github.com/smaccm/smaccm/issues/40

--------------------------------------
-- potential logical design flaws resulting in data corruption
--------------------------------------	

	-- CWE-131 - check buffer size
	-- outgoing queue size <= incoming queue size on connection (not necessary for data port)
	-- AND compare outgoing and incoming rates
	-- AND compare data type/size on ports
	-- 	 
	forall_connections_no_buffer_overflow (self: component) <=
	** "CWE131: For all connections: No buffer overflow due to queue size, rate, data type/size" ** 
		forall  (pc : {conn for (conn:connection)| is_port_connection(conn)}).
			no_buffer_overflow(pc)

	no_buffer_overflow (conn: connection) <=
	** "CWE131: For given connection: No buffer overflow due to queue size, rate, data type/size" ** 
	source_queue_size_lessorequal_destination_queue_size (conn) and 
	destination_period_handles_queue_faster_than_source_period_fills_queue (conn) and 
	same_source_and_destination_type_or_data_size(conn)
	 
	 
	source_queue_size_lessorequal_destination_queue_size (c : connection) <=
	** "For connection: source queue size <= destination queue size on connection " c ** 
		queue_size (source(c)) <= queue_size (destination(c))
 
	destination_period_handles_queue_faster_than_source_period_fills_queue (conn : connection) <=
	** "For connection: destination handles all queue elements in single dispatch faster than source fills it on " conn **
	let src : component = source_component(conn);
	let dst : component = destination_component(conn);
		((is_event_data_port_connection (conn) or is_event_port_connection (conn)) and
		has_property (dst, Timing_Properties::Period) and 
		has_property (src, Timing_Properties::Period)) =>
		property (dst, Timing_Properties::Period) / queue_size (destination (conn))
	 	<=
	 	property (src, Timing_Properties::Period) 

	 
	same_source_and_destination_type_or_data_size (c : connection) <=
	** "For connection: same type or data size on connection ends " c ** 
	(has_type(source(c)) and has_type(destination(c))) => (type(source(c)) = type(destination(c)) or
		(has_property (type(source(c)), Memory_Properties::Data_Size) and has_property (type(destination(c)), Memory_Properties::Data_Size
	)) => property (type(source(c)), Memory_Properties::Data_Size) = property (destination(c), Memory_Properties::Data_Size))

	--
	-- CWE-362 - potential race condition
	-- check whether synchronization protocol is used on shared data component
	
	forall_data_shared_components_uses_concurrency_control_protocol (self:component) <=
	** "CWE362: For all data components: if shared data component uses concurrency control" ** 
	forall (c : data) . connections(d) <> {} =>
	concurrency_control_on_data_shared_component (c)
	
	-- we check data component or the data access features of the connection for the presence of concurrency control 
	concurrency_control_on_data_shared_component (d : data) <=
	** "CWE362: if shared data component uses concurrency control" d **
	let sharedComp: bool = exists (conn : connections(d)) . is_data_access(conn);
	not sharedComp or has_concurrency_control (d) or 
	forall (conn : connections(d)) . is_data_access(conn) =>
	has_concurrency_control (source(conn)) or 
 	has_concurrency_control (destination(conn))
 
	
	
	
	
	--
	--  CWE-805: buffer access with incorrect length value
	--  For this one, we assume that types used between interacting
	--  components do not match. So, we add a rule to check
	--  that data are consistent.
	--
	--  This is now implemented for integer and float. Support
	--  for arrays is included but limited.
	--
	--  To be checked, pending on bug #645 in osate
	--  https://github.com/osate/osate2-core/issues/645
	--
	forall_connections_same_data_type_or_size_and_consistent_data_model_spec (self: component) <=
	** "CWE805: For all connections: Same data type/size and consistent data model spec" ** 
	forall (conn : connection) . is_data_port_connection(conn) =>
	same_source_and_destination_type_or_data_size(conn) and consistent_data_model (conn)
	
	
	consistent_data_model (conn : connection) <=
	** "Consistent data model specification for connection " conn ** 
	(has_type(source(conn)) and has_type(destination(conn))) =>
	( 	check_data_properties_definition (type(source (conn))) and  
		check_data_properties_definition (type(destination (conn))) => 
		check_data_properties_consistencies (type(source (conn)), type(destination (conn)))
	)
	
	check_data_properties_definition (thedata : aadl) : bool =
	has_property (thedata,Data_Model::Data_Representation)
	andthen if (property(thedata,Data_Model::Data_Representation) = "Integer")
	        then 
				has_property(thedata,Data_Model::Integer_Range) and has_property(thedata,Data_Model::Number_Representation)
			else
				if (property(thedata,Data_Model::Data_Representation) = "float")
		        then 
					has_property(thedata,Data_Model::Real_Range) and has_property(thedata,Data_Model::Number_Representation)
				else
					if (property(thedata,Data_Model::Data_Representation) = "Array")
			        then 
						has_property(thedata,Data_Model::MyDimension)
					else
						false
	
	check_data_properties_consistencies (thedata1 : aadl, thedata2 : aadl) <=
	** "Data model specifications " thedata1 " and " thedata2 " are consistent" **
	(property (thedata1,Data_Model::Data_Representation) = property (thedata2,Data_Model::Data_Representation))
	andthen if (property(thedata1,Data_Model::Data_Representation) = "integer")
	        then 
	        	(property (thedata1,Data_Model::Integer_Range) = property (thedata2,Data_Model::Integer_Range))
	        	and
	        	(property (thedata1,Data_Model::Number_Representation) = property (thedata2,Data_Model::Number_Representation))
			else
				if (property(thedata1,Data_Model::Data_Representation) = "float")
		        then 
			        (property (thedata1,Data_Model::Real_Range) = property (thedata2,Data_Model::Real_Range))
		        	and
		        	(property (thedata1,Data_Model::Number_Representation) = property (thedata2,Data_Model::Number_Representation))
				else
				if (property(thedata1,Data_Model::Data_Representation) = "array")
		        then 
					(property (thedata1,Data_Model::MyDimension) = property (thedata2,Data_Model::MyDimension))
				else
					false
	

	**};
end Security_Exposure_Resolute;
